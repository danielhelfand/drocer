/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.plumblarrick.andrew.cityrecordtextextractor;

import com.plumblarrick.andrew.cityrecordtextextractor.IssueModel.Page;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 *
 * @author calarrick
 */
public class IssueProcessor {

    private String startPdfFileName;
    private String firstTextFileName;
    private String sortedColumnsFileName;
    private Boolean indexFlag = false;
    Pattern tabSplit = Pattern.compile("\\\t");
    Pattern colBreak = Pattern.compile("\\|");
    Pattern firstLineIssuePagination = Pattern.compile(
            "[0-9]{1,3}\\t([0-9]{1,3})\\s*");
    Matcher pageMatcher = firstLineIssuePagination.matcher("");


    /**
     * Instantiates an IsssueExtractorPositional object that handles interaction
     * with the main PDFBox API to parse text from one pdf document into a text
     * file. Returns an indication of success or failure, as a String.
     *
     * @param fileName The name of the starting document, e.g. "test.pdf"
     * @param outFileName The name of the text file to generate, e.g. "test.txt"
     * @return String Will either confirm successful extraction to "example.txt"
     * or indicate that "example.pdf" was not extracted.
     */
    public String extractIssue(String fileName, String outFileName) {

        startPdfFileName = fileName;
        firstTextFileName = outFileName;
        IssueExtractorPositional ex = new IssueExtractorPositional();

        try {
            ex.extractToFile(startPdfFileName, firstTextFileName);
            return "Extracted " + startPdfFileName + " to " + firstTextFileName;
        } catch (IOException io) {
            return "IO Exception: could not extract " + startPdfFileName;

        }
    }


    /**
     * Allows a parsed text file to be provided to the method directly. Simply
     * adds that parameter to the class-level variables and calls the main
     * readLinesToPagees() method. For use if we need to separate "line reading"
     * ordering from text extraction.
     *
     * @param fileName
     * @throws FileNotFoundException
     * @throws IOException
     * @return IssueModel
     */
    public IssueModel readLinesToPages(String fileName) throws
            FileNotFoundException,
            IOException {

        firstTextFileName = fileName;
        IssueModel currIssue = readLinesToPages();
        return currIssue;
    }


    /**
     * Reads the text file generated by the text stripper that is wrapped by the
     * extractIssue method call and models the original document as a group of
     * (corrected) pages and columns.
     *
     * @return IssueModel Object representation of the PDF contents divided into
     * pages and columns with extraction of page numbering and fixes to ordering
     * @throws FileNotFoundException
     * @throws IOException
     */
    public IssueModel readLinesToPages() throws FileNotFoundException,
            IOException {

        BufferedReader textIn = new BufferedReader(new FileReader(
                firstTextFileName), 100000);
        IssueModel currIssue = new IssueModel();
        String issueName;
        Page page = null;
        int pagesAdded = 0;
        int pageLineCounter = 0;

        String currLine = textIn.readLine();

        if (currLine.substring(0, 12).equals("Source file: ")) {
            issueName = currLine.substring(13);
        } else {
            issueName = currLine;
        }
        currIssue.setIssueID(issueName);

        while ((currLine = textIn.readLine()) != null) {

            //currLine = textIn.readLine();
            if (currLine.equals("") || currLine.equals("\n")) {
                continue;
            }

            if ((currLine.length() >= 12) && currLine.substring(0, 12).equals(
                    "[Start Page ")) {
                pagesAdded++;
                page = currIssue.addPage(pagesAdded);
                pageLineCounter = 0;
                page.setCountedPageNum(pagesAdded);
                System.out.println(pagesAdded);
                page.addLine(currLine);

            } else if (page != null) {
                pageLineCounter = page.addLine(currLine);
                System.out.println(pageLineCounter);

            } else {
                page = currIssue.addPage(pagesAdded + 1);
                page.addLine("Page missing correct starting flag.");
                pageLineCounter = page.addLine(currLine);

            }

        }
        currIssue = columnSortIssue(currIssue);
        return currIssue;
    }

    protected IssueModel columnSortIssue(IssueModel issue) {

        List<Page> pages = issue.getPages();
        //replace this w iteration functionality on model

        for (Page page : pages) {
            page = processPage(page);
        }

        return issue;

    }
    //need something topull sinfle col areas out for ordered reintegration


    //calls a page processing method for each known page
    //layout in the set of PDF docs.
    //Ultimately is likely a better and more configurable
    //way to set up this logic.
    protected Page processPage(Page page) {

        //as above
        if (indexFlag == true) {
            page = processIndexPage(page);
        }

        switch (page.getCountedPageNum()) {

            case 0:
                page = processSimplePage(page);
                break;
            case 1:
                page = processSimplePage(page);
                break;
            case 2:

                page = processSimplePage(page);
                break;

            case 3:

                indexFlag = false;
                //ensures flag reset once in each issue
                page = processCRFirstBodyPage(page);
                break;

            default:

                page = processCRMainBodyPage(page);
                break;

        }
        return page;
    }


    protected Page processIndexPage(Page page) {

        page = processSimplePage(page);
        return page;
    }

    protected Page processSimplePage(Page page) {

        List<String> lines = page.getPageContents();


        StringBuilder col = new StringBuilder();
        lines.stream()
                .forEach((line) -> {
                    col.append(line);
                    col.append("\n");
                });

        String oneColumn = col.toString();
        List<String> columns = new ArrayList<>();
        columns.add(oneColumn);
        page.setColumns(columns);

        return page;


    }

    protected Page processCRFirstBodyPage(Page page) {

        List<String> lines = page.getPageContents();
        page.setPageNum(3);

        boolean intro;
        intro = true;
        String pNum = "";
        String meetingDate = new String();
        int lineCounter = 0;
        String header = "";


        StringBuilder headerContent = new StringBuilder();
        String content = "";


        while (intro == true) {

            for (String line : lines) {

                lineCounter++;

                String[] splitLine = colBreak.split(line);
                if (splitLine.length == 1) {

                    String[] tabDivided = tabSplit.split(splitLine[0]);
                    if (tabDivided.length >= 2) {
                        content = tabDivided[1];
                    }

                    if (content.startsWith("MOND")
                            || content.startsWith("TUES")
                            || content.startsWith("WEDN")
                            || content.startsWith("THURS")
                            || content.startsWith("FRI")
                            || content.startsWith("SAT")
                            || content.startsWith("SUND")) {


                        intro = false;
                        header = headerContent.toString();
                        meetingDate = content;
                        break;

                    }
                }
            }
        }

        StringBuilder columnOne = new StringBuilder();
        StringBuilder columnTwo = new StringBuilder();
        StringBuilder columnThree = new StringBuilder();
        StringBuilder strays = new StringBuilder();

        String[] measureAndText;
        columnOne.append(header);

        columnOne.append("City Council\n");
        columnOne.append(meetingDate);
        columnOne.append("\n");
        int numColsOnLine = 0;
        int xAxisStart = 0;
        String text = "";


        for (int z = lineCounter; z < lines.size(); z++) {

            String line = lines.get(z);
            String[] sections = colBreak.split(line);
            numColsOnLine = sections.length;
            lineCounter++;

            int columnOneLine = 74;
            int columnTwoLine = 230;
            int columnThreeLine = 380;
            boolean columnOnePresent = false;
            boolean columnTwoPresent = false;
            boolean columnThreePresent = false;
            boolean straysPresent = false;
            //determine columns
            if (line.equals("") || line.equals("\n") || line.equals(
                    " ")) {
                continue;
            } else if (lineCounter == lines.size()) {

                pageMatcher.reset(sections[0]);

                if (sections.length == 1 && pageMatcher.matches()) {

                    pNum = pageMatcher.group(1);
                    page.setIndexPageNum(Integer.parseInt(pNum));


                }
                page.setFooter(line);


            } else {
                for (int i = 0; i < sections.length; i++) {

                    measureAndText = sections[i].split("\t");
                    if (measureAndText.length == 2) {
                        try {
                            xAxisStart = Integer.parseInt(measureAndText[0]);
                            text = measureAndText[1];
                        } catch (NumberFormatException e) {
                            strays.append(measureAndText[1]);
                        }
                    }

                    if (xAxisStart <= columnTwoLine * .9) {
                        //use this or fixed addition for expected col w?
                        //do need factor to left too to pickup mal-aligned
                        //units (probably)
                        columnOne.append(text);
                        columnOnePresent = true;
                    } else if (xAxisStart > columnTwoLine * 0.9
                            && xAxisStart
                            < columnThreeLine * .9) {
                        columnTwo.append(text);
                        columnTwoPresent = true;
                    } else if (xAxisStart >= columnThreeLine * 0.9
                            && xAxisStart
                            < columnThreeLine * 1.5) {
                        columnThree.append(text);
                        columnThreePresent = true;
                    } else {
                        strays.append(xAxisStart + " " + text);
                    }


                }//end columnar for loop

                if (columnOnePresent) {
                    columnOne.append("\n");
                }
                if (columnTwoPresent) {
                    columnTwo.append("\n");
                }
                if (columnThreePresent) {
                    columnThree.append("\n");
                }
                if (straysPresent) {
                    strays.append("\n");
                }
            }
        }

        //end line iteration

        columnOne.append("[End Column One]\n");
        columnTwo.append("[End Column Two]\n");
        columnThree.append("[End Column Three]\n");
        strays.append("[End Non-placed Text]\n");

        List<String> columns = new ArrayList<>();
        columns.add(columnOne.toString());
        columns.add(columnTwo.toString());
        columns.add(columnThree.toString());
        columns.add(strays.toString());

        page.setColumns(columns);

        for (String column : columns) {
            System.out.println(column);
        }

        return page;

    }

    private int findIndexStart(Page page) {

        List<String> lines = page.getPageContents();
        int indexStartLine = 0;
        int lineCounter = 0;
        for (String line : lines) {

            lineCounter++;
            String[] sections = colBreak.split(line);
            if (sections.length == 1) {
                String[] colOne = tabSplit.split(sections[0]);
                String colOneText = "";
                if (colOne.length > 1) {
                    colOneText = colOne[1];
                }
                if (colOneText.startsWith("Index")) {
                    //check ahead
                    int checkAheadLine = lineCounter;
                    boolean checkTest = false;
                    int i = 0;

                    while (checkTest == false && i < 8) {
                        String aheadLine = lines.get(lineCounter + i);
                        i++;
                        String[] aheadSections = colBreak.split(aheadLine);
                        for (int z = 0; z < aheadSections.length; z++) {
                            String[] col = tabSplit.split(aheadSections[z]);
                            String colText = "";
                            if (col.length >= 1) {
                                colText = col[1];
                            }
                            if (colText.startsWith("Bold figures")) {
                                checkTest = true;

                            }
                        }
                    }
                    if (checkTest == true) {
                        indexStartLine = lineCounter;
                    }

                }

            }

        }

        return indexStartLine;
    }

    protected Page processCRMainBodyPage(Page page) {

        List<String> lines = page.getPageContents();
        int numColsOnLine = 0;
        int lineCounter = 0;
        String pNum = "";
        int indexStartLine = 0;


        String[] measureAndText;
        String text = "";
        int xAxisStart = 0;
        String[] checker = new String[2];

        StringBuilder columnOne = new StringBuilder();
        columnOne.append("[Start Column One]\n");
        StringBuilder columnTwo = new StringBuilder();
        columnTwo.append("[Start Column Two]\n");
        StringBuilder columnThree = new StringBuilder();
        columnThree.append("[Column Three Start]\n");
        StringBuilder strays = new StringBuilder();
        strays.append("[Couldn't place these:] \n");
        StringBuilder indexEntries = new StringBuilder();
        

        if (!indexFlag) {
            indexStartLine = findIndexStart(page);
        }

        for (String line : lines) {

            String[] sections = colBreak.split(line);
            numColsOnLine = sections.length;
            lineCounter++;
            //remember this means lineCounter variable is one greater than 
            //the list index through all following logic

            int columnOneLine = 74;
            int columnTwoLine = 230;
            int columnThreeLine = 380;

            if (sections.length >= 1) {
                checker = tabSplit.split(sections[0]);
            }
            
            if (indexStartLine != 0 && lineCounter == indexStartLine){
                
                indexFlag = true;
                line = processIndexLine(line);
                indexEntries.append(line);
                indexEntries.append("\n");
               
                continue;
                
            }
            if (indexFlag){
                
                line = processIndexLine(line);
                indexEntries.append(line);
                indexEntries.append("\n");
                continue;
            }


            if (line.equals("") || line.equals("\n") || line.equals(
                    " ")) {
                continue;
            }

            if (lineCounter == 2) {

                pageMatcher.reset(sections[0]);

                if (sections.length == 3 && pageMatcher.matches()) {

                    pNum = pageMatcher.group(1);
                    page.setPageNum(Integer.parseInt(pNum));

                } else if (sections.length == 3) {

                    pageMatcher.reset(sections[2]);
                    if (pageMatcher.matches()) {
                        pNum = pageMatcher.group(1);
                    }
                    page.setPageNum(Integer.parseInt(pNum));

                }

                page.setHeader(line);

            } else if (lineCounter == lines.size()) {

                pageMatcher.reset(sections[0]);

                if (sections.length == 1 && pageMatcher.matches()) {

                    pNum = pageMatcher.group(1);
                    page.setIndexPageNum(Integer.parseInt(pNum));


                }
                page.setFooter(line);

            } else if (sections.length == 1
                    && sections.length > 140) {

                measureAndText = tabSplit.split(sections[0]);
                if (measureAndText.length > 1) {
                    columnOne.append(measureAndText[1]);
                }

            } else {


                boolean columnOnePresent = false;
                boolean columnTwoPresent = false;
                boolean columnThreePresent = false;
                boolean straysPresent = false;
                //determine columns


                for (int i = 0; i < sections.length; i++) {

                    String columnOneCandidate = "";
                    String columnTwoCandidate = "";
                    String columnThreeCandidate = "";

                    measureAndText = sections[i].split("\t");
                    if (measureAndText.length == 2) {
                        try {
                            xAxisStart = Integer.parseInt(measureAndText[0]);
                            text = measureAndText[1];
                        } catch (NumberFormatException e) {
                            strays.append(measureAndText[1]);
                        }
                    }

                    if (xAxisStart <= columnTwoLine * .9) {
                        //use this or fixed addition for expected col w?
                        //do need factor to left too to pickup mal-aligned
                        //units (probably)
                        columnOne.append(text);
                        //columnOneCandidate = text;
                        columnOnePresent = true;
                    } else if (xAxisStart > columnTwoLine * 0.97
                            && xAxisStart
                            < columnThreeLine * .97) {
                        columnTwo.append(text);
                        columnTwoPresent = true;
                    } else if (xAxisStart >= columnThreeLine * 0.97) {
                        columnThree.append(text);
                        columnThreePresent = true;
                    } else {
                        strays.append(xAxisStart);
                        strays.append(" ");
                        strays.append(text);
                    }


                }//end columnar for loop

                if (columnOnePresent) {
                    columnOne.append("\n");
                }
                if (columnTwoPresent) {
                    columnTwo.append("\n");
                }
                if (columnThreePresent) {
                    columnThree.append("\n");
                }
                if (straysPresent) {
                    strays.append("\n");
                }
            }

        }//end line iteration

        columnOne.append(
                "[End Column One]\n");
        columnTwo.append(
                "[End Column Two]\n");
        columnThree.append(
                "[End Column Three]\n");
        strays.append(
                "[End Non-placed Text]\n");
        indexEntries.append(
                "[End Index Entries]\n");


        List<String> columns = new ArrayList<>();

        columns.add(columnOne.toString());
        columns.add(columnTwo.toString());
        columns.add(columnThree.toString());
        columns.add(strays.toString());
        columns.add(indexEntries.toString());

        page.setColumns(columns);


        for (String column : columns) {
            System.out.println(column);
        }

        return page;

    }
    
    private String processIndexLine(String line){
        
        String[] sections = colBreak.split(line);
        StringBuilder lineBuilder = new StringBuilder();
        
        for (String section: sections){
            
            String[] measureAndText = tabSplit.split(section);
            if (measureAndText.length > 1){
            lineBuilder.append(measureAndText[1]);
            }
            
        }
        line = lineBuilder.toString();
                
        return line;
        
    }


    protected Page processCRDirectoryOfOfficials(Page page) {

        List<String> lines = page.getPageContents();
        int numColsOnLine = 0;
        int lineCounter = 0;
        String pNum = "";

        String[] measureAndText;
        String text = "";
        int xAxisStart = 0;


        Pattern colBreak = Pattern.compile("\\|");
        Pattern tabSplit = Pattern.compile("\\\t");

        StringBuilder columnOne = new StringBuilder();
        StringBuilder columnTwo = new StringBuilder();

        StringBuilder strays = new StringBuilder();
        strays.append("[Couldn't place these:] \n");

        for (String line : lines) {

            String[] sections = colBreak.split(line);
            numColsOnLine = sections.length;
            lineCounter++;
            //remember this means lineCounter variable is one greater than 
            //the list index through all following logic

            int columnOneLine = 74;
            int columnTwoLine = 305;
            //int columnThreeLine = 380;


            boolean columnOnePresent = false;
            boolean columnTwoPresent = false;
            boolean columnThreePresent = false;
            boolean straysPresent = false;
            //determine columns
            for (int i = 0; i < sections.length; i++) {

                measureAndText = tabSplit.split(sections[i]);
                if (measureAndText.length == 2) {
                    try {
                        xAxisStart = Integer.parseInt(measureAndText[0]);
                        text = measureAndText[1];
                    } catch (NumberFormatException e) {
                        strays.append(measureAndText[1]);
                    }
                }

                if (xAxisStart <= columnTwoLine) {
                    //use this or fixed addition for expected col w?
                    //do need factor to left too to pickup mal-aligned
                    //units (probably)
                    columnOne.append(text);
                    columnOnePresent = true;
                } else if (xAxisStart > columnTwoLine) {
                    columnTwo.append(text);
                    columnTwoPresent = true;

                } else {
                    strays.append(xAxisStart + " " + text);
                }


            }//end columnar for loop

            if (columnOnePresent) {
                columnOne.append("\n");
            }
            if (columnTwoPresent) {
                columnTwo.append("\n");
            }

            if (straysPresent) {
                strays.append("\n");
            }
        }

        //end line iteration

        columnOne.append("[End Column One]\n");
        columnTwo.append("[End Column Two]\n");

        strays.append("[End Non-placed Text]\n");


        List<String> columns = new ArrayList<>();
        columns.add(columnOne.toString());
        columns.add(columnTwo.toString());

        columns.add(strays.toString());


        page.setColumns(columns);


        return page;


    }


    public void printIssue(IssueModel issue, String fileName) throws
            FileNotFoundException, UnsupportedEncodingException {

        try {
            List<Page> pages = issue.getPages();
            Writer fileOut;


            fileOut = (new BufferedWriter(new PrintWriter(fileName, "UTF-8")));


            for (Page page : pages) {

                List<String> columns = page.getColumns();
                String issuePageNumber = String.valueOf(page.getPageNum());
                String indexPageNumber = String.valueOf(page.getIndexPageNum());


                try {


                    fileOut.append("[Page" + issuePageNumber + "]\n");
                    fileOut.append("[Indexed (running) page" + indexPageNumber
                            + "]\n");
                    if (!(columns == null)) {
                        for (String column : columns) {

                            fileOut.append(column);


                        }
                    }
                    fileOut.write("[end page]\n");


                } catch (IOException ex) {
                    Logger.getLogger(IssueProcessor.class
                            .getName())
                            .log(Level.SEVERE, null, ex);
                }

            }

            fileOut.flush();
            fileOut.close();


        } catch (IOException ex) {
            Logger.getLogger(IssueProcessor.class
                    .getName())
                    .log(Level.SEVERE, null, ex);
        }

    }


}
